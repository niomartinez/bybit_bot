//@version=6
// Â© nioboi
strategy("ICT Silver Bullet [THE ASCENT]", overlay=true, max_bars_back=5000, max_lines_count=500, max_labels_count=500, max_boxes_count=500, default_qty_type=strategy.percent_of_equity, default_qty_value=10, initial_capital=10000, currency=currency.USD, pyramiding=1)

//================ IMPORT LIBRARIES ================ courtesy of @TFlab
//import Order Block Refiner
import TFlab/OrderBlockRefiner_TradingFinder/2 as Refiner
//import Order Block Drawing Library
import TFlab/OrderBlockDrawing_TradingFinder/4 as Drawing
//import FVG Detector Library
import TFlab/FVGDetectorLibrary/3 as FVG

//================ STRATEGY PARAMETERS ================
// FVG Settings
choice = 'All FVG'
cBullFVG = input.color(#4dd0e160, 'Bull FVG Color', inline='fvg', group='FVG Settings')
cBearFVG = input.color(#ffc1b160, 'Bear FVG Color', inline='fvg', group='FVG Settings')
extend = input.bool(true, 'extend FVG', inline='fvg', group='FVG Settings')

// FVG Library Settings (from ICT 2022 Mentorship)
PFVGFilter = input.bool(false, 'Enable FVG Width Filter', group='FVG Settings')
PFVGFilterType = input.string('Defensive', 'Filter Type', ['Very Aggressive', 'Aggressive', 'Defensive', 'Very Defensive'], group='FVG Settings')
FVG_Length = input.int(120, 'FVG Length', minval=1, group='FVG Settings')
MLFVG = input.string('Proximal', 'FVG Internal Entry Level', ['Proximal', '50 % OB', 'Distal'], group='FVG Settings')

// Display FVG Settings
DFVGShow = input.bool(true, 'Show Demand FVG', group='FVG Settings')
SFVGShow = input.bool(true, 'Show Supply FVG', group='FVG Settings')

// Silver Bullet Session Settings
showSB = input.bool(true, 'Show SB session', inline='SB', group='Silver Bullet Session')
col_SB = input.color(#b2b5be50, '', inline='SB', group='Silver Bullet Session')

// Trade Management Settings (Pyramiding Removed - Only 1 trade per direction)

// Entry Settings
entry_method = input.string('Proximal', 'Entry Level', options=['Proximal', '50% OB', 'Distal'], group='Entry Settings', tooltip='Determines where to place limit orders within the Fair Value Gap')

// Stop Loss Settings
atr_length = input.int(14, 'ATR Length', minval=1, group='Stop Loss Settings')
atr_smoothing = input.string('RMA', 'ATR Smoothing', options=['RMA', 'SMA', 'EMA', 'WMA'], group='Stop Loss Settings')
atr_multiplier = input.float(2.0, 'ATR Multiplier', minval=0.1, step=0.1, group='Stop Loss Settings')

// Take Profit Settings
risk_reward_ratio = input.float(2.0, 'Risk:Reward Ratio', minval=0.1, step=0.1, group='Take Profit Settings')

// Breakeven Settings
enable_breakeven = input.bool(true, 'Enable Breakeven Stop Loss', group='Breakeven Settings', tooltip='Move stop loss to breakeven when price reaches halfway to take profit')
breakeven_buffer_pips = input.float(2.0, 'Breakeven Buffer (Pips)', minval=0.0, step=0.1, group='Breakeven Settings', tooltip='Additional pips beyond entry price to account for fees')

// Display Settings
show_trade_levels = input.bool(true, 'Show Entry/SL/TP Levels', group='Display Settings')
show_trade_labels = input.bool(true, 'Show Trade Labels', group='Display Settings')
show_atr_trackprice = input.bool(true, 'Track ATR Lines with Price', group='Display Settings')

//================ SILVER BULLET SESSIONS ================
// Time functions
timeSess(timezone, session) => 
    not na(time(timeframe.period, session, timezone))

// Silver Bullet Sessions
SB_LN_per = timeSess("America/New_York", "0300-0400") // London Open (3 AM - 4 AM NY time)
SB_AM_per = timeSess("America/New_York", "1000-1100") // AM Session (10 AM - 11 AM NY time)
SB_PM_per = timeSess("America/New_York", "1400-1500") // PM Session (2 PM - 3 PM NY time)

// Session status
is_in_SB = SB_LN_per or SB_AM_per or SB_PM_per
strSB = is_in_SB and not is_in_SB[1]  // Start of any SB session
endSB = not is_in_SB and is_in_SB[1]  // End of any SB session

//================ FVG TRACKING TYPE ================
type FVG_Data
    int bar_index
    float high_price
    float low_price
    bool is_bullish
    bool is_tapped
    bool created_while_in_trade

//================ ORDER STATUS TRACKING TYPE ================
type OrderStatus
    string order_id
    string status  // "pending", "filled", "cancelled"
    int session_bar  // Bar index when order was created

//================ ORDER VISUAL TRACKING TYPE ================
type OrderVisuals
    string order_id
    line entry_line
    line sl_line  
    line tp_line
    label entry_label
    label sl_label
    label tp_label

//================ BREAKEVEN TRACKING TYPE ================
type BreakevenTracker
    string trade_id
    float entry_price
    float original_stop
    float take_profit
    float halfway_price
    bool is_long
    bool breakeven_triggered

//================ SESSION TRACKING VARIABLES ================
var bool sessionActive = false
var FVG_Data[] untapped_fvgs = array.new<FVG_Data>()
var int sessionStartBar = 0
var bool was_in_position_last_bar = false
var int cancelled_orders_count = 0
var OrderStatus[] tracked_orders = array.new<OrderStatus>()
var OrderVisuals[] active_order_visuals = array.new<OrderVisuals>()
var BreakevenTracker breakeven_tracker = na
var int trade_counter = 0
var bool has_pending_order = false

// Reset session tracking when new session starts
if strSB
    sessionActive := true
    sessionStartBar := bar_index
    // Clear previous session FVGs
    array.clear(untapped_fvgs)
    trade_counter := 0  // Reset trade counter for new session
    has_pending_order := false  // Reset pending order flag
    
    // Clean up old order tracking data from previous sessions
    // Keep only pending orders that might still be relevant
    if array.size(tracked_orders) > 0
        for i = array.size(tracked_orders) - 1 to 0
            tracked_order = array.get(tracked_orders, i)
            // Remove filled and cancelled orders from previous sessions
            if tracked_order.status == "filled" or tracked_order.status == "cancelled"
                array.remove(tracked_orders, i)
    
    // Visual indication of new session start
    // if showSB
    //     label.new(bar_index, low, "NEW SB SESSION\nStarted", color=color.blue, textcolor=color.white, style=label.style_label_up, size=size.small)

if endSB
    sessionActive := false
    array.clear(untapped_fvgs)
    
    // DON'T clear breakeven tracker - keep it active even after session ends
    // breakeven_tracker := na  // REMOVED - let it continue managing the position
    
    // Smart cancellation: only cancel orders that are still "pending"
    var string[] pending_to_cancel = array.new<string>()
    
    if array.size(tracked_orders) > 0
        for i = 0 to array.size(tracked_orders) - 1
            tracked_order = array.get(tracked_orders, i)
            if tracked_order.status == "pending"
                // This order is still a limit order that hasn't been filled
                array.push(pending_to_cancel, tracked_order.order_id)
                // Mark as cancelled
                tracked_order.status := "cancelled"
    
    // Cancel only the pending orders
    if array.size(pending_to_cancel) > 0
        for i = 0 to array.size(pending_to_cancel) - 1
            order_id = array.get(pending_to_cancel, i)
            strategy.cancel(order_id)
            
            // Debug: Show which order was cancelled
            debug_cancel_text = "ORDER CANCELLED\nID: " + order_id
            //label.new(bar_index, close + (high - low) * (0.2 + i * 0.1), 
            //         debug_cancel_text, color=color.red, textcolor=color.white, 
            //         style=label.style_label_left, size=size.tiny)
                         
        cancelled_orders_count := cancelled_orders_count + array.size(pending_to_cancel)
        has_pending_order := false  // Clear pending order flag when orders are cancelled
        
        // Visual indication of cancelled orders
        // if showSB
        //     label.new(bar_index, high + (high - low) * 0.1, "CANCELLED " + str.tostring(array.size(pending_to_cancel)) + " PENDING ORDERS", color=color.orange, textcolor=color.white, style=label.style_label_down, size=size.tiny)
    
    // Don't clear tracked_orders - keep for reference of filled orders
    // Visual cleanup is handled by cleanupOrderVisuals() function only
    // No visual cleanup here to avoid interfering with active trades

//================ ATR CALCULATION ================
atr_ma(source, length, smoothing) =>
    if smoothing == 'RMA'
        ta.rma(source, length)
    else if smoothing == 'SMA'
        ta.sma(source, length)
    else if smoothing == 'EMA'
        ta.ema(source, length)
    else
        ta.wma(source, length)

atr_value = atr_ma(ta.tr(true), atr_length, atr_smoothing)

// Plot ATR-based Stop Loss Levels (like the reference indicator)
atr_upper = high + (atr_value * atr_multiplier)  // Short stop loss level
atr_lower = low - (atr_value * atr_multiplier)   // Long stop loss level

plot(atr_upper, title="ATR Short SL", color=color.new(color.red, 80), linewidth=1, trackprice=show_atr_trackprice)
plot(atr_lower, title="ATR Long SL", color=color.new(color.green, 80), linewidth=1, trackprice=show_atr_trackprice)

//================ POSITION TRACKING ================
// Track position changes
bool just_exited_long = strategy.position_size[1] > 0 and strategy.position_size == 0
bool just_exited_short = strategy.position_size[1] < 0 and strategy.position_size == 0
bool currently_in_position = strategy.position_size != 0

// Position counters removed - single trade only

// Update order status when positions change (orders get filled)
if strategy.position_size != strategy.position_size[1]
    // Position changed - check if any pending orders got filled
    has_pending_order := false  // Clear pending order flag when position changes
    
    if array.size(tracked_orders) > 0
        for i = 0 to array.size(tracked_orders) - 1
            tracked_order = array.get(tracked_orders, i)
            if tracked_order.status == "pending"
                // Check if this order ID matches any current position
                // We can't directly check, but if position size changed, likely an order filled
                // Mark the most recent pending order as filled
                tracked_order.status := "filled"
                
                // Debug: Show order fill
                // debug_fill_text = "ORDER FILLED\nID: " + tracked_order.order_id + "\nSession: " + (sessionActive ? "ACTIVE" : "ENDED")
                // label.new(bar_index, strategy.position_size > 0 ? low - (high - low) * 0.1 : high + (high - low) * 0.1, 
                //          debug_fill_text, color=sessionActive ? color.green : color.orange, textcolor=color.white, 
                //          style=strategy.position_size > 0 ? label.style_label_up : label.style_label_down, size=size.tiny)
                break

// Mark FVGs created while in position
if currently_in_position and not was_in_position_last_bar
    // Just entered position, mark future FVGs as created while in trade
    was_in_position_last_bar := true
else if not currently_in_position and was_in_position_last_bar
    // Just exited position
    was_in_position_last_bar := false
else
    was_in_position_last_bar := currently_in_position

//================ FVG DETECTION & TRACKING ================
// Library-based FVG detection (like ICT 2022 Mentorship)
[DConditionFVG, DDFVG, DPFVG, BarDFVG, SConditionFVG, SDFVG, SPFVG, BarSFVG] = FVG.FVGDetector(PFVGFilter ? 'On' : 'Off', PFVGFilterType, false, false)

// Simple FVG detection during sessions for our own tracking
bullish_fvg_detected = sessionActive and low > high[2]
bearish_fvg_detected = sessionActive and high < low[2]

// Add detected FVGs to tracking array
if bullish_fvg_detected
    new_fvg = FVG_Data.new(bar_index, low, high[2], true, false, currently_in_position)
    array.push(untapped_fvgs, new_fvg)

if bearish_fvg_detected
    new_fvg = FVG_Data.new(bar_index, low[2], high, false, false, currently_in_position)
    array.push(untapped_fvgs, new_fvg)

// Dynamic FVG Drawing using the library (like ICT 2022 Mentorship)
if bar_index - BarDFVG < 500 and DConditionFVG and sessionActive
    Drawing.OBDrawing('Demand', DConditionFVG, DDFVG, DPFVG, BarDFVG, true, FVG_Length, MLFVG, MLFVG, true, false, DFVGShow, false, cBullFVG, #ffffff00)

if bar_index - BarSFVG < 500 and SConditionFVG and sessionActive  
    Drawing.OBDrawing('Supply', SConditionFVG, SDFVG, SPFVG, BarSFVG, true, FVG_Length, MLFVG, MLFVG, true, false, SFVGShow, false, cBearFVG, #ffffff00)

//================ HELPER FUNCTIONS ================
// Entry price calculation
getEntryPrice(fvgHigh, fvgLow, isBullish) =>
    if entry_method == 'Proximal'
        isBullish ? fvgHigh : fvgLow  // Proximal (closest to current price)
    else if entry_method == '50% OB'
        (fvgHigh + fvgLow) / 2  // Middle of FVG
    else  // Distal
        isBullish ? fvgLow : fvgHigh  // Distal (furthest from current price)

// Calculate stop loss and take profit
getStopLoss(entryPrice, isBullish) =>
    atrDistance = atr_value * atr_multiplier
    isBullish ? entryPrice - atrDistance : entryPrice + atrDistance

getTakeProfit(entryPrice, stopPrice) =>
    riskDistance = math.abs(entryPrice - stopPrice)
    rewardDistance = riskDistance * risk_reward_ratio
    entryPrice > stopPrice ? entryPrice + rewardDistance : entryPrice - rewardDistance

// Find next untapped FVG for trading
findNextFVG(preferBullish) =>
    FVG_Data result = na
    
    if array.size(untapped_fvgs) > 0
        // First, look for FVGs created while we were NOT in a position (immediate FVGs)
        for i = 0 to array.size(untapped_fvgs) - 1
            fvg = array.get(untapped_fvgs, i)
            if not na(fvg) and not fvg.is_tapped and not fvg.created_while_in_trade and fvg.is_bullish == preferBullish
                result := fvg
                break
                
        // If no immediate FVGs found, look for FVGs created while in position
        if na(result)
            for i = 0 to array.size(untapped_fvgs) - 1
                fvg = array.get(untapped_fvgs, i)
                if not na(fvg) and not fvg.is_tapped and fvg.created_while_in_trade and fvg.is_bullish == preferBullish
                    result := fvg
                    break
    
    result

//================ TRADE EXECUTION LOGIC ================
// Check if we can enter a long trade (no position and no pending orders)
canEnterLong = sessionActive and strategy.position_size == 0 and not has_pending_order

// Check if we can enter a short trade (no position and no pending orders)
canEnterShort = sessionActive and strategy.position_size == 0 and not has_pending_order

// Function to execute trade
executeTrade(fvg, direction, tradeId) =>
    // Safety check - ensure FVG is not na
    if na(fvg)
        runtime.error("executeTrade called with na FVG object")
    
    // Mark FVG as tapped
    fvg.is_tapped := true
    
    // Calculate trade levels
    entryPrice = getEntryPrice(fvg.high_price, fvg.low_price, fvg.is_bullish)
    stopPrice = getStopLoss(entryPrice, fvg.is_bullish)
    tpPrice = getTakeProfit(entryPrice, stopPrice)
    
    // Track this order ID
    array.push(tracked_orders, OrderStatus.new(tradeId, "pending", bar_index))
    
    // Enter trade
    if direction == "Long"
        strategy.entry(tradeId, strategy.long, limit=entryPrice, comment="SB Long")
        
        // Alert for long limit order
        alert('{"symbol":"' + syminfo.ticker + 
              '","side":"long",' + 
              '"entry":"' + str.tostring(entryPrice, "#.####") + '",' +
              '"stop_loss":"' + str.tostring(stopPrice, "#.####") + '",' + 
              '"take_profit":"' + str.tostring(tpPrice, "#.####") + '",' + 
              '"trigger_time":"' + str.tostring(timenow) + '",' +
              '"max_lag":"20",' +
              '"order_type":"limit",' +
              '"priority":"1",' +
              '"strategy_id":"silver_bullet"}', alert.freq_once_per_bar_close)
    else
        strategy.entry(tradeId, strategy.short, limit=entryPrice, comment="SB Short")
        
        // Alert for short limit order
        alert('{"symbol":"' + syminfo.ticker + 
              '","side":"short",' + 
              '"entry":"' + str.tostring(entryPrice, "#.####") + '",' +
              '"stop_loss":"' + str.tostring(stopPrice, "#.####") + '",' + 
              '"take_profit":"' + str.tostring(tpPrice, "#.####") + '",' + 
              '"trigger_time":"' + str.tostring(timenow) + '",' +
              '"max_lag":"20",' +
              '"order_type":"limit",' +
              '"priority":"1",' +
              '"strategy_id":"silver_bullet"}', alert.freq_once_per_bar_close)
    
    // Set exit orders
    strategy.exit(tradeId + "_exit", tradeId, stop=stopPrice, limit=tpPrice)
    
    // Create order visuals immediately when order is placed
    var OrderVisuals visuals = na
    
    if show_trade_levels or show_trade_labels
        line_color = fvg.is_bullish ? color.green : color.red
        label_x_position = bar_index + 25  // Move labels to the right
        
        // Create lines
        entry_line = show_trade_levels ? line.new(bar_index, entryPrice, bar_index+20, entryPrice, color=line_color, style=line.style_dashed, width=2) : na
        sl_line = show_trade_levels ? line.new(bar_index, stopPrice, bar_index+20, stopPrice, color=color.red, style=line.style_dashed, width=2) : na
        tp_line = show_trade_levels ? line.new(bar_index, tpPrice, bar_index+20, tpPrice, color=color.blue, style=line.style_dashed, width=2) : na
        
        // Create labels (moved to the right)
        entry_text = (direction == "Long" ? "LONG" : "SHORT") + " ENTRY\n" + str.tostring(entryPrice, '#.####')
        entry_style = fvg.is_bullish ? label.style_label_down : label.style_label_up
        entry_color = fvg.is_bullish ? color.green : color.red
        
        entry_label = show_trade_labels ? label.new(label_x_position, entryPrice, entry_text, color=entry_color, textcolor=color.white, style=entry_style, size=size.small) : na
        sl_label = show_trade_labels ? label.new(label_x_position, stopPrice, 'SL\n' + str.tostring(stopPrice, '#.####'), color=color.red, textcolor=color.white, style=label.style_label_up, size=size.small) : na
        tp_label = show_trade_labels ? label.new(label_x_position, tpPrice, 'TP\n' + str.tostring(tpPrice, '#.####'), color=color.blue, textcolor=color.white, style=label.style_label_down, size=size.small) : na
        
        // Store visuals for tracking
        visuals := OrderVisuals.new(tradeId, entry_line, sl_line, tp_line, entry_label, sl_label, tp_label)
        array.push(active_order_visuals, visuals)
    
    // Draw FVG box
    box_color = fvg.is_bullish ? cBullFVG : cBearFVG
    border_color = fvg.is_bullish ? color.new(color.blue, 100) : color.new(color.red, 100)
    
    if extend
        box.new(fvg.bar_index-2, fvg.low_price, bar_index+10, fvg.high_price, border_color=border_color, bgcolor=box_color)
    else
        box.new(fvg.bar_index-2, fvg.low_price, fvg.bar_index, fvg.high_price, border_color=border_color, bgcolor=box_color)

// Main trade execution logic
if sessionActive
    // Look for immediate FVG opportunities (first priority)
    if canEnterLong
        nextBullFVG = findNextFVG(true)
        if not na(nextBullFVG)
            if not nextBullFVG.created_while_in_trade
                trade_counter := trade_counter + 1
                tradeId = "Long_" + str.tostring(trade_counter)
                executeTrade(nextBullFVG, "Long", tradeId)
                has_pending_order := true  // Mark that we have a pending order
                
                // Create breakeven tracker after trade execution
                if enable_breakeven
                    entryPrice = getEntryPrice(nextBullFVG.high_price, nextBullFVG.low_price, nextBullFVG.is_bullish)
                    stopPrice = getStopLoss(entryPrice, nextBullFVG.is_bullish)
                    tpPrice = getTakeProfit(entryPrice, stopPrice)
                    halfwayPrice = entryPrice + (tpPrice - entryPrice) / 2
                    breakeven_tracker := BreakevenTracker.new(tradeId, entryPrice, stopPrice, tpPrice, halfwayPrice, true, false)
                    
                    // Debug: Show breakeven setup
                    debug_text = "BREAKEVEN SETUP\nEntry: " + str.tostring(entryPrice, "#.##") + "\nHalfway: " + str.tostring(halfwayPrice, "#.##") + "\nTP: " + str.tostring(tpPrice, "#.##")
                    label.new(bar_index + 5, entryPrice, debug_text, color=color.yellow, textcolor=color.black, style=label.style_label_right, size=size.tiny)
    
    if canEnterShort  
        nextBearFVG = findNextFVG(false)
        if not na(nextBearFVG)
            if not nextBearFVG.created_while_in_trade
                trade_counter := trade_counter + 1
                tradeId = "Short_" + str.tostring(trade_counter)
                executeTrade(nextBearFVG, "Short", tradeId)
                has_pending_order := true  // Mark that we have a pending order
                
                // Create breakeven tracker after trade execution
                if enable_breakeven
                    entryPrice = getEntryPrice(nextBearFVG.high_price, nextBearFVG.low_price, nextBearFVG.is_bullish)
                    stopPrice = getStopLoss(entryPrice, nextBearFVG.is_bullish)
                    tpPrice = getTakeProfit(entryPrice, stopPrice)
                    halfwayPrice = entryPrice - (entryPrice - tpPrice) / 2
                    breakeven_tracker := BreakevenTracker.new(tradeId, entryPrice, stopPrice, tpPrice, halfwayPrice, false, false)
                    
                    // Debug: Show breakeven setup
                    debug_text = "BREAKEVEN SETUP\nEntry: " + str.tostring(entryPrice, "#.##") + "\nHalfway: " + str.tostring(halfwayPrice, "#.##") + "\nTP: " + str.tostring(tpPrice, "#.##")
                    label.new(bar_index + 5, entryPrice, debug_text, color=color.yellow, textcolor=color.black, style=label.style_label_right, size=size.tiny)
    
    // Check for post-exit opportunities (after TP)
    if just_exited_long and canEnterLong
        nextBullFVG = findNextFVG(true)
        if not na(nextBullFVG)
            trade_counter := trade_counter + 1
            tradeId = "Long_" + str.tostring(trade_counter)
            executeTrade(nextBullFVG, "Long", tradeId)
            has_pending_order := true  // Mark that we have a pending order
            
            // Create breakeven tracker after trade execution
            if enable_breakeven
                entryPrice = getEntryPrice(nextBullFVG.high_price, nextBullFVG.low_price, nextBullFVG.is_bullish)
                stopPrice = getStopLoss(entryPrice, nextBullFVG.is_bullish)
                tpPrice = getTakeProfit(entryPrice, stopPrice)
                halfwayPrice = entryPrice + (tpPrice - entryPrice) / 2
                breakeven_tracker := BreakevenTracker.new(tradeId, entryPrice, stopPrice, tpPrice, halfwayPrice, true, false)
                
                // Debug: Show breakeven setup
                debug_text = "BREAKEVEN SETUP\nEntry: " + str.tostring(entryPrice, "#.##") + "\nHalfway: " + str.tostring(halfwayPrice, "#.##") + "\nTP: " + str.tostring(tpPrice, "#.##")
                label.new(bar_index + 5, entryPrice, debug_text, color=color.yellow, textcolor=color.black, style=label.style_label_right, size=size.tiny)
    
    if just_exited_short and canEnterShort
        nextBearFVG = findNextFVG(false) 
        if not na(nextBearFVG)
            trade_counter := trade_counter + 1
            tradeId = "Short_" + str.tostring(trade_counter)
            executeTrade(nextBearFVG, "Short", tradeId)
            has_pending_order := true  // Mark that we have a pending order
            
            // Create breakeven tracker after trade execution
            if enable_breakeven
                entryPrice = getEntryPrice(nextBearFVG.high_price, nextBearFVG.low_price, nextBearFVG.is_bullish)
                stopPrice = getStopLoss(entryPrice, nextBearFVG.is_bullish)
                tpPrice = getTakeProfit(entryPrice, stopPrice)
                halfwayPrice = entryPrice - (entryPrice - tpPrice) / 2
                breakeven_tracker := BreakevenTracker.new(tradeId, entryPrice, stopPrice, tpPrice, halfwayPrice, false, false)
                
                // Debug: Show breakeven setup
                debug_text = "BREAKEVEN SETUP\nEntry: " + str.tostring(entryPrice, "#.##") + "\nHalfway: " + str.tostring(halfwayPrice, "#.##") + "\nTP: " + str.tostring(tpPrice, "#.##")
                label.new(bar_index + 5, entryPrice, debug_text, color=color.yellow, textcolor=color.black, style=label.style_label_right, size=size.tiny)

// Function to clean up visuals for completed/cancelled orders
cleanupOrderVisuals() =>
    if array.size(active_order_visuals) > 0
        // Clean up visuals only when positions are actually closed or orders were cancelled
        // Keep visuals active even after session ends as long as position exists
        for i = array.size(active_order_visuals) - 1 to 0
            visuals = array.get(active_order_visuals, i)
            order_id = visuals.order_id
            
            // Find the order status
            order_status = "unknown"
            if array.size(tracked_orders) > 0
                for j = 0 to array.size(tracked_orders) - 1
                    if array.get(tracked_orders, j).order_id == order_id
                        order_status := array.get(tracked_orders, j).status
                        break
            
            // Only clean up if:
            // 1. Order was cancelled (never got filled)
            // 2. Order was filled BUT position is now closed (strategy.position_size == 0)
            // Keep visuals for active positions regardless of session status
            should_cleanup = false
            
            // SAFETY: Never clean up if there's an active position
            if strategy.position_size != 0
                should_cleanup := false
            else if order_status == "cancelled"
                should_cleanup := true
            else if order_status == "filled" and strategy.position_size == 0
                // Position was closed after being filled - now safe to clean up
                should_cleanup := true
            
            if should_cleanup
                // Delete visual elements
                if not na(visuals.entry_line)
                    line.delete(visuals.entry_line)
                if not na(visuals.sl_line)
                    line.delete(visuals.sl_line)
                if not na(visuals.tp_line)
                    line.delete(visuals.tp_line)
                if not na(visuals.entry_label)
                    label.delete(visuals.entry_label)
                if not na(visuals.sl_label)
                    label.delete(visuals.sl_label)
                if not na(visuals.tp_label)
                    label.delete(visuals.tp_label)
                
                // Remove from array
                array.remove(active_order_visuals, i)

// Clean up visuals on each bar
cleanupOrderVisuals()

//================ BREAKEVEN STOP LOSS MANAGEMENT ================
if enable_breakeven and not na(breakeven_tracker)
    // Check if this trade is still active
    if strategy.position_size != 0
        // Check if price has reached halfway point and breakeven hasn't been triggered yet
        if not breakeven_tracker.breakeven_triggered
            price_reached_halfway = false
            
            // Debug: Show we're checking for breakeven every bar (only show occasionally)
            if bar_index % 10 == 0 and show_trade_labels
                debug_text = "CHECKING BREAKEVEN\nCurrent: " + str.tostring(close, "#.##") + "\nHalfway: " + str.tostring(breakeven_tracker.halfway_price, "#.##")
                label.new(bar_index, low - (high - low) * 0.05, debug_text, color=color.gray, textcolor=color.white, style=label.style_label_up, size=size.tiny)
            
            if breakeven_tracker.is_long
                // For long trades, check if high reached halfway price (catches intrabar movements)
                price_reached_halfway := high >= breakeven_tracker.halfway_price
            else
                // For short trades, check if low reached halfway price (catches intrabar movements)
                price_reached_halfway := low <= breakeven_tracker.halfway_price
            
            if price_reached_halfway
                // Calculate breakeven stop loss with buffer
                buffer_amount = breakeven_buffer_pips * syminfo.mintick * 10  // Convert pips to price
                new_stop_loss = breakeven_tracker.is_long ? 
                               breakeven_tracker.entry_price + buffer_amount : 
                               breakeven_tracker.entry_price - buffer_amount
                
                // IMPORTANT: Cancel the old exit order first, then create new one
                strategy.cancel(breakeven_tracker.trade_id + "_exit")
                strategy.exit(breakeven_tracker.trade_id + "_exit_be", breakeven_tracker.trade_id, stop=new_stop_loss, limit=breakeven_tracker.take_profit)
                
                // Mark as triggered
                breakeven_tracker.breakeven_triggered := true
                
                // Debug: Always show breakeven activation
                be_text = "BREAKEVEN ACTIVATED\nOld SL: " + str.tostring(breakeven_tracker.original_stop, "#.##") + "\nNew SL: " + str.tostring(new_stop_loss, "#.##")
                be_color = breakeven_tracker.is_long ? color.green : color.red
                label.new(bar_index, new_stop_loss, be_text, color=be_color, textcolor=color.white, style=label.style_label_right, size=size.small)
        else
            // Debug: Show that breakeven was already triggered
            if barstate.islast and show_trade_labels
                debug_text = "BREAKEVEN\nALREADY ACTIVE"
                label.new(bar_index, close, debug_text, color=color.blue, textcolor=color.white, style=label.style_label_left, size=size.tiny)
    else
        // Position is closed, clear the tracker
        breakeven_tracker := na

//================ VISUALIZATIONS ================
// Session lines
var line[] session_lines = array.new_line()

// Handle session start and end lines
if strSB and showSB
    array.push(session_lines, line.new(bar_index, close, bar_index, close + syminfo.mintick, color=col_SB, extend=extend.both))

if endSB and showSB
    array.push(session_lines, line.new(bar_index, close, bar_index, close + syminfo.mintick, color=col_SB, extend=extend.both))

// Clean up old lines
if array.size(session_lines) > 100
    line.delete(array.shift(session_lines))

// Plot session markers
plotchar(SB_LN_per and not SB_LN_per[1] and showSB, 
         title='3-4 AM', location=location.top, text='3-4 AM\nNY', color=color(na), textcolor=col_SB, size=size.small)

plotchar(SB_AM_per and not SB_AM_per[1] and showSB, 
         title='10-11 AM', location=location.top, text='10-11 AM\nNY', color=color(na), textcolor=col_SB, size=size.small)

plotchar(SB_PM_per and not SB_PM_per[1] and showSB, 
         title='2-3 PM', location=location.top, text='2-3 PM\nNY', color=color(na), textcolor=col_SB, size=size.small)

// Session background
// bgcolor(sessionActive ? color.new(col_SB, 90) : na, title="Silver Bullet Session")

//================ STATISTICS TABLE ================
var table statsTable = table.new(position.top_right, 6, 8, color.black, color.white, 2, color.gray, 2)

if barstate.islast
    // Calculate statistics
    netProfit = strategy.netprofit
    winRate = strategy.closedtrades > 0 ? (strategy.wintrades / strategy.closedtrades) * 100 : 0
    profitFactor = strategy.grossloss != 0 ? strategy.grossprofit / math.abs(strategy.grossloss) : 0
    maxDrawdown = strategy.max_drawdown
    
    // Format statistics
    netProfitStr = str.tostring(netProfit, "$#.##")
    winRateStr = str.tostring(winRate, "#.##") + "%"
    profitFactorStr = str.tostring(profitFactor, "#.##")
    maxDrawdownStr = str.tostring(maxDrawdown, "$#.##")
    
    // Set table headers (bigger and spanning columns)
    table.cell(statsTable, 0, 0, "ICT SILVER BULLET STRATEGY", bgcolor=color.blue, text_color=color.white, text_size=size.normal)
    table.merge_cells(statsTable, 0, 0, 5, 0)
    
    table.cell(statsTable, 0, 1, "PERFORMANCE STATISTICS", bgcolor=color.navy, text_color=color.white, text_size=size.small)
    table.merge_cells(statsTable, 0, 1, 5, 1)
    
    // Performance metrics (larger text)
    table.cell(statsTable, 0, 2, "Net Profit:", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 2, netProfitStr, text_color=color.white, text_size=size.small)
    table.cell(statsTable, 2, 2, "Win Rate:", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 3, 2, winRateStr, text_color=color.white, text_size=size.small)
    
    table.cell(statsTable, 0, 3, "Profit Factor:", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 3, profitFactorStr, text_color=color.white, text_size=size.small)
    table.cell(statsTable, 2, 3, "Max Drawdown:", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 3, 3, maxDrawdownStr, text_color=color.white, text_size=size.small)
    
    table.cell(statsTable, 0, 4, "Total Trades:", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 4, str.tostring(strategy.closedtrades), text_color=color.white, text_size=size.small)
    table.cell(statsTable, 2, 4, "Wins/Losses:", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 3, 4, str.tostring(strategy.wintrades) + "/" + str.tostring(strategy.losstrades), text_color=color.white, text_size=size.small)
    
    // Current status section
    table.cell(statsTable, 0, 5, "CURRENT STATUS", bgcolor=color.navy, text_color=color.white, text_size=size.small)
    table.merge_cells(statsTable, 0, 5, 5, 5)
    
    table.cell(statsTable, 0, 6, "Session Active:", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 6, sessionActive ? "YES" : "NO", text_color=sessionActive ? color.green : color.red, text_size=size.small)
    table.cell(statsTable, 2, 6, "Pending Orders:", text_color=color.white, text_size=size.small)
    
    // Count pending orders
    pending_count = 0
    if array.size(tracked_orders) > 0
        for i = 0 to array.size(tracked_orders) - 1
            if array.get(tracked_orders, i).status == "pending"
                pending_count := pending_count + 1
    
    table.cell(statsTable, 3, 6, str.tostring(pending_count), text_color=color.yellow, text_size=size.small)
    
    table.cell(statsTable, 0, 7, "Position:", text_color=color.white, text_size=size.small)
    position_text = strategy.position_size > 0 ? "LONG" : strategy.position_size < 0 ? "SHORT" : "NONE"
    position_color = strategy.position_size > 0 ? color.green : strategy.position_size < 0 ? color.red : color.white
    table.cell(statsTable, 1, 7, position_text, text_color=position_color, text_size=size.small)
    table.cell(statsTable, 2, 7, "Cancelled:", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 3, 7, str.tostring(cancelled_orders_count), text_color=color.orange, text_size=size.small)